
		*********************** Active Record Query Interface ***********************
		
--> In active record , we can find the data using Rails instead of SQL queries. Active record will perform queries on database for you and is compatible with MySQL, MariaDB, PostgreSQL and SQLite.


# Retrieving objects from database

--> To retrieve object, active record provides finder methods.

--> Methods are as follows:

:annotate
:find
:create_with
:distinct
:eager_load
:extending
:extract_associated
:from
:group
:having
:includes
:joins
:left_outer_joins
:limit
:lock
:none
:offset
:optimizer_hints
:order
:preload
:readonly
:references
:reorder
:reselect
:reverse_order
:select
:where


# Retrieving a single object

=> find

--> method will give the result corresponding to the specified primary key that matches any supplied options

3.0.0 :003 > Doctor.find(2)
  Doctor Load (0.8ms)  SELECT `doctors`.* FROM `doctors` WHERE `doctors`.`id` = 2 LIMIT 1
 =>                                                           
#<Doctor:0x0000559fe6491fc0                                   
 id: 2,                                                       
 name: "Subhash Atreja",                                      
 mobile: "9864572826",                                        
 address: "SCO-12, Sector - 5, Karnal",                       
 experience: 10,                                              
 created_at: Tue, 30 Aug 2022 09:29:46.453074000 UTC +00:00,  
 updated_at: Thu, 01 Sep 2022 11:51:19.552535000 UTC +00:00,  
 emails: nil>
 
 Doctor.find([1,5]) - will give the records with ID's from 1 to 5                            
 
 Note : The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.
 

=> take

--> retrieve records without any implicit ordering

Doctor.take
  Doctor Load (0.8ms)  SELECT `doctors`.* FROM `doctors` LIMIT 1
 =>                                                           
#<Doctor:0x00007fac80661690                                   
 id: 2,                                                       
 name: "Subhash Atreja",                                      
 mobile: "9864572826",                                        
 address: "SCO-12, Sector - 5, Karnal",                       
 experience: 10,                                              
 created_at: Tue, 30 Aug 2022 09:29:46.453074000 UTC +00:00,  
 updated_at: Thu, 01 Sep 2022 11:51:19.552535000 UTC +00:00,  
 emails: nil>
 
Note: The take method returns nil if no record is found and no exception will be raised.

--> We can also pass arguments in numeric integer, which will give result upto that number of results


=> find_by

--> gives the first record matching the condition

3.0.0 :006 > Doctor.find_by(name: 'Suresh')			# =~ Doctor.where(name: 'Suresh).take
  Doctor Load (0.4ms)  SELECT `doctors`.* FROM `doctors` WHERE `doctors`.`name` = 'Suresh' LIMIT 1
 =>                                                           
#<Doctor:0x00007fac8054c2c8                                   
 id: 3,                                                       
 name: "Suresh",                                              
 mobile: "9876543210",                                        
 address: "Sco - 90,  Sector-10, Faridabad",                  
 experience: 5,                                               
 created_at: Wed, 31 Aug 2022 07:48:32.353049000 UTC +00:00,  
 updated_at: Wed, 31 Aug 2022 07:48:32.353049000 UTC +00:00,  
 emails: nil>                                                
 
----------------------------------------------------------------------------------------------------------------------------------

# Retrieve multiple objects

=> find_each

--> This method retrieves records in batches and then yields each one to the block.

3.0.0 :007 > Doctor.find_each do |doc|
3.0.0 :008 >   puts doc.name
3.0.0 :009 > end
  Doctor Load (0.8ms)  SELECT `doctors`.* FROM `doctors` ORDER BY `doctors`.`id` ASC LIMIT 1000
Subhash Atreja                                                                   
Suresh                                                                           
 => nil  

--> This retrieves customers in batches of 1000 and yields them to the block one by one.

:Options

-- :batch_size = Specify size to give record in batch
-- :start = used from which number of record we have to start
-- :finish = used at which number we have to stop
-- :error_on_ignore = Overrides the application config to specify if an error should be raised when an order is present in the relation.


=> find_in_batches

--> The find_in_batches method is similar to find_each, since both retrieve batches of records. The difference is that find_in_batches yields batches to the block as an array of models, instead of individually. Array Block size is here too 1000


	Doctor.find_in_batches do |doc|
	       doc.each do |d|
	           puts d.name
	       end
	end
	
:Options

-- :batch_size
-- :start
-- :finish
-- :error_on_ignore

----------------------------------------------------------------------------------------------------------------------------------

# Conditions

--> where methods allow you to specify conditions to limit the records returned.

=> Pure string condition

3.0.0 :030 > Doctor.where(name: "Suresh")
  Doctor Load (0.4ms)  SELECT `doctors`.* FROM `doctors` WHERE `doctors`.`name` = 'Suresh'
 =>                                                           
[#<Doctor:0x0000559fe6e954e0                                  
  id: 3,                                                      
  name: "Suresh",                                             
  mobile: "9876543210",                                       
  address: "Sco - 90,  Sector-10, Faridabad",                 
  experience: 5,                                              
  created_at: Wed, 31 Aug 2022 07:48:32.353049000 UTC +00:00, 
  updated_at: Wed, 31 Aug 2022 07:48:32.353049000 UTC +00:00, 
  emails: nil>]   
  

=> Array conditions

If the parameter is varying:

	Book.where("title = ?", params[:title])	# This is recommended
	
		OR
	
	Book.where("title = #{params[:title]}")


If you want to specify multiple conditions 

	Book.where("title = ? AND out_of_print = ?", params[:title], false)


:Place-holder conditions

Book.where("created_at >= :start_date AND created_at <= :end_date",{start_date: params[:start_date], end_date: params[:end_date]})

--> This makes for clearer readability if you have a large number of variable conditions.


=> Hash conditions

--> Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax.

:Equality condition

	Book.where(out_of_print: true)

:Range condition

	Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

:Subset conditions

	Customer.where(orders_count: [1,3,5])

=> NOT conditions

	Customer.where.not(orders_count: [1,3,5])
	--> This will return the customers whose order count is not 1,3,5
	
=> OR conditions
	
	Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1,3,5]))

=> AND conditions

	Customer.where(last_name: 'Smith').where(orders_count: [1,3,5]))	# Chaining of where method
	
		OR
	
	Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))
	
----------------------------------------------------------------------------------------------------------------------------------

# Ordering

To retrieve data in a specific order from database

	Book.order(:created_at)
	          
	          OR
	          
	Book.order("created_at")
	
: For specifying ASC or DESC

	Book.order(created_at: :desc)
	          
	          OR
	          
	Book.order(created_at: :asc)
	          
	          OR
	          
	Book.order("created_at DESC")
	          
	          OR
	          
	Book.order("created_at ASC")


:Ordering multiple fields

	Book.order(title: :asc, created_at: :desc)
		
		OR
		
	Book.order(:title, created_at: :desc)
		
		OR
		
	Book.order("title ASC, created_at DESC")
		
		OR
		
	Book.order("title ASC", "created_at DESC")

----------------------------------------------------------------------------------------------------------------------------------

# Selecting specific fields

--> By default, Model.find selects all the fields from the result set using select *. To select only a subset of fields from the result set, you can specify the subset via the select method.

	Book.select(:isbn, :out_of_print)
		
		OR
		
	Book.select("isbn, out_of_print")

	--> This will return the record of only two columns
	
: If we want to select distinct record, then you use

	Customer.select(:last_name).distinct

----------------------------------------------------------------------------------------------------------------------------------

# Limit and offset
--> Limit is used to return limited records

	Customer.limit(5)
	--> This will return only 5 records
	
--> Offset is used to skip the records

	Customer.limit(5).offset(30)
	--> This will return the 5 records after skipping 30 records
	
----------------------------------------------------------------------------------------------------------------------------------

# Group

--> To apply a GROUP BY clause to the SQL fired by the finder, you can use the group method.

	Order.select("created_at").group("created_at")
	--> This will select the column created_at and group the distinct dates
	
:Total of grouped items

	Order.group(:status).count
	
----------------------------------------------------------------------------------------------------------------------------------

# Having

--> This method is used when group method is used 
	
	Order.select("created_at, sum(total) as total_price").group("created_at").having("sum(total) > ?", 200)
	
:Passing the above Object to a varibale

              big_orders = Order.select("created_at, sum(total) as total_price").group("created_at").having("sum(total) > ?", 200)
	big_orders[0].total_price
	--> Returns the total price for the first Order object

----------------------------------------------------------------------------------------------------------------------------------

# Overriding conditions

1. unscope
--> You can specify certain conditions to be removed using the unscope method. For example:

	Book.where('id > 100').limit(20).order('id desc').unscope(:order)
	--> This will execute the where and limit method and leave the order method
	
	Book.where(id: 10, out_of_print: false).unscope(where: :id)
	--> This will remove the id condition from the query
	
2. only
--> only is used to specify which methods is to be performed

	Book.where('id > 10').limit(20).order('id desc').only(:order, :where)
	
3. reselect
--> The reselect method overrides an existing select statement.

	Book.select(:title, :isbn).reselect(:created_at)

4. reorder
--> If your association have already specified any ordering way. Then you can use reorder to override it.

For. e.g - Author class includes

	class Author < ApplicationRecord
	  has_many :books, -> { order(year_published: :desc) }
	end
	
           We execute:
                
                Author.find(10).books

	SQL execute :-
		SELECT * FROM authors WHERE id = 10 LIMIT 1
		SELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC
           We execute:
           
	Author.find(10).books.reorder('year_published ASC')

	SQL execute :-
		SELECT * FROM authors WHERE id = 10 LIMIT 1
		SELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC
		
5. reverse_order
--> This method reverse the ordering clause if specified

For e.g - 	Book.where("author_id > 10").order(:year_published).reverse_order
	
	SQL execute :-
		SELECT * FROM books WHERE author_id > 10 ORDER BY year_published DESC

: If no ordering clause is present, then this method orders the primary key in reverse order.

	Book.where("author_id > 10").reverse_order

	SQL execute :-
		SELECT * FROM books WHERE author_id > 10 ORDER BY books.id DESC

6. rewhere
--> This method overrides an existing, named where condition.

For e.g -	Book.where(out_of_print: true).rewhere(out_of_print: false)
	
	SQL execute :-
		SELECT * FROM books WHERE `out_of_print` = 0
----------------------------------------------------------------------------------------------------------------------------------
